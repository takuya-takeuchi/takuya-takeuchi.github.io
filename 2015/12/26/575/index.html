<!DOCTYPE html><html lang="ja-JP"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Core"><link rel="icon" href="/images/favicon.ico" type="image/x-icon"><title>.NETで難読化を試してみる 第6回 · A certain engineer "COMPLEX"</title><meta name="description" content="前回の続き。今回は難読化を有効にした際、Any CPUのアセンブリがx86になる問題の解決策についてです。

Explanation前回は最高レベルの難読化にしたが故に、x86のアセンブリになってしまいました。難読化レベルがデフォルトでは起こらない問題でしたので、何かしらのオプションが作用しているの"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/blogcard.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.1.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:127px;"><h3 title=""><a href="/">A certain engineer &quot;COMPLEX&quot;</a></h3><div class="description"><p>とある技術者の劣等感</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/takuya-takeuchi"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="noopener" href="https://twitter.com/takuya_takeuchi"><i class="fa fa-twitter-square"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.facebook.com/takuya.takeuchi.sns"><i class="fa fa-facebook-square"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2020 </span><i class="fa fa-star"></i><span> Core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="search"><div class="text"><input placeholder="検索ワードを入力してください" id="search-text" onkeypress="javascript:search(event)"></div><div class="btn"><a><i class="fa fa-search"></i></a></div></div><div class="nav"><li><a href="/">ホーム</a></li><li><a href="/archives">アーカイブ</a></li><li><a href="/tags">タグ</a></li><li><a href="/about">自己紹介</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>.NETで難読化を試してみる 第6回</a></h3></div><div class="post-content"><p><a target="_blank" rel="noopener" href="https://taktak.jp/2015/12/19/560">前回</a>の続き。<br>今回は難読化を有効にした際、Any CPUのアセンブリがx86になる問題の解決策についてです。</p>
<a id="more"></a>
<h1 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h1><p>前回は最高レベルの難読化にしたが故に、x86のアセンブリになってしまいました。<br>難読化レベルがデフォルトでは起こらない問題でしたので、何かしらのオプションが作用しているのは間違いないでしょう。</p>
<p>そこで Babel Obfuscator のヘルプを覗くと下記のような記述が</p>
<blockquote>
<p>Obfuscating x64 Assemblies<br>Depending on the target platform, the Visual Studio compiler emits the desired CPU architecture into the PE header. Users of Visual Studio can set the target platform in the build project’s property page. The default platform is “Any CPU” which indicates that the compiled assembly can run on any version of Windows. When a managed executable is loaded, Windows examines the PE header to determine whether the application requires 32-bit or 64-bit CPU architecture to ensure that it matches the computer’s CPU type. Windows ensures the compatibility of 32-bit applications on 64-bit CPUs with a technology called WoW64 (Windows on Windows64) that emulates 32-bit instruction sets on a 64-bit CPU, albeit with a performance loss. When the application architecture is known, Windows loads the framework execution engine Just-In-Time compiler (JIT) specific to the executable target platform (x86, x64, Itanium). On x64 operating systems, the MSIL code of assemblies targeting “Any CPU” platform is validated by the .NET Framework runtime before execution.<br>To protect an assembly from being disassembled by tools like .NET Reflector, Babel can insert into any MSIL method invalid byte codes that do not correspond to any MSIL op-code instruction (–invalidopcodes). The resulting assembly is no longer IL verifiable and Windows can execute it only on a WoW64 subsystem. Suppose that the obfuscated assembly is a DLL referenced by an executable that runs in full 64-bit environment. When the runtime tries to load the DLL obfuscated with invalid op-codes, it checks the CPU JIT requirements, and because they do not match, it throws an InvalidProgramException exception. The only way to generate obfuscated DLLs or executables fully compatible with x64 is to disable the injection of invalid op-codes during obfuscation.</p>
</blockquote>
<p>訳) x64アセンブリの難読化<br>対象のプラットフォームへの依存、Visual Studio コンパイラはPEヘッダーに必要とするCPUアーキテクチャを発行する。Visual Studioのユーザはビルド設定のプロパティページで対象プラットフォームを設定できます。既定のプラットフォームは “Any CPU” で、コンパイルされたアセンブリがどのバージョンのWindowsでも動作できることを示します。(訳注：正しくは、x86, x64のCPUアーキテクチャの違いであって、Windowsのバージョンではない)。マネージドの実行ファイルがロードされるとき、WindowsはPEヘッダーを検証し、アプリケーションが必要とするのが、32bit CPUまたは64bit CPUかどうかを、コンピュータのCPUの種別と一致するかどうかで確認する。Windowsは64bit CPU上で32bit命令セットをエミュレートするWoW64 (Windows on Windows64) と呼ばれるテクノロジーを持つ64bit CPU上での32bitアプリケーションの互換性を保証するが、パフォーマンスの損失を伴う。アプリケーションのアーキテクチャが既知であるとき、Windowsは、実行可能な対象プラットフォーム (x86, x64, Itanium) を指定するための、フレームワーク実行エンジンである Just-In-Time コンパイラ (JIT) をロードします。x64 のOS上で、”Any CPU”プラットフォームを対象としているMSILコードのアセンブリは実行前に.NET Framework ランタイムによって検証されます。<br>.NET Reflectorのようなツールによる逆アセンブルからアセンブリを保護するために、BabelはいくつかのMSILメソッドの不正なバイトコード-どのMSILの命令コードにも対応しない (–invalidopcodes) -を挿入することができます。その結果のアセンブリは、もはや IL (中間言語) として検証可能ではなく、WindowsはWoW64のサブシステム上でのみでしか実行させることができません。<br>難読化されたアセンブリが、完全な64bit環境上で実行される実行可能ファイルから参照されることもあるでしょう。ランタイムが不正な命令コードで難読化されたDLLのロードを試みるとき、CPU JIT 要求仕様をチェックし、それらが合致しないが故に、InvalidProgramException例外をスローします。x64と完全な互換性を持つ、難読化されたDLLまたは実行可能ファイルを生成する唯一の手段は、難読化中の不正な命令コードの挿入を無効にすることです。</p>
<p>少し長いですが、要約すると、逆アセンブルを防ぐためのオプション (–invalidopcodes) を使うと、x64上での互換性を維持できなくなるよ、って言ってます。<br>なので、このオプションを無効にすればAny CPUを維持することができるはずです。<br>再度ヘルプのオプション説明を見ると、</p>
<blockquote>
<p>Use this option to emit invalid MSIL op-codes at the beginning of every method. This will stop reflection tools like .NET Reflector to display IL method disassembly. Warning: This will make your assembly not verifiable.<br>Normally, code that is not verifiable cannot run on x64 Operating Systems. This option should be switched off if the obfuscated assembly targets x64 platforms.</p>
</blockquote>
<p>訳) このオプションは不正なMSIL命令コードを全てのメソッドの先頭に挿入するために使用します。これは.NET Reflectorのような中間言語メソッドの逆アセンブルを表示するツールを阻止します。警告：このツールはアセンブルの検証不可にします。<br>通常、検証できないコードはx64OS上では実行できません。このオプションは難読化されるアセンブリがx64プラットフォームを対象とする場合はオフにするべきです。</p>
<p>とあります。<br>画面上、該当するオプションは、<strong>Control Flow Obfuscation</strong> の <strong>Emit Invalid Opcodes</strong> になります。<br>最初の説明を見ると、逆アセンブルを防ぐオプションが悪いので、<strong>Protection &amp; Code Generation</strong> の <strong>Anti Reflection</strong> や　<strong>Prevent ILdasm Disassembly</strong> が悪いように見えますが、<strong>全く無関係</strong>です。</p>
<p>Emit Invalid Opcodesだけ無効にして、再度難読化を実行します。</p>
<p><a href="../../../../public/2015/12/Emit_Invalid_Opcodes.png"><img src="../../../../public/2015/12/Emit_Invalid_Opcodes-1024x695.png" alt="Emit Invalid Opcodes"></a></p>
<p>(1) 実行結果の検証</p>
<p><strong>オプション有効時</strong></p>
<p><a href="../../../../public/2015/12/Before.png"><img src="../../../../public/2015/12/Before-1024x642.png" alt="Before"></a></p>
<p><strong>オプション無効時</strong></p>
<p><a href="../../../../public/2015/12/After.png"><img src="../../../../public/2015/12/After-1024x642.png" alt="After"></a></p>
<p>dotPeek での結果がAny CPUを表すようになったことがわかります。<br>最高の難読化レベルでもこのオプションは外しておいた方が無難かもしれません。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>一通り、難読化の処理を見てきましたが、ツールのオプションが豊富で、きちんと使い方を知っておかないと、思わぬ落とし穴にはまります。<br>国産の難読化ツールもありますが、正直海外製が一歩も二歩もリードしているのが印象でした。</p>
<p>自分は、オープンソースの開発を始めたので、難読化ツールの出番は減りますが、ひょっとしたら会社で使うようなことがあった場合に、この知識は有効になるでしょう。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-12-26</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Microsoft/" title="Microsoft">Microsoft </a><a class="tag" href="/categories/NET-Framework/" title=".NET Framework">.NET Framework </a><a class="tag" href="/categories/ソフトウェア紹介/" title="ソフトウェア紹介">ソフトウェア紹介 </a><a class="tag" href="/categories/NET-Framework/NETで○○○を試してみる/" title=".NETで○○○を試してみる">.NETで○○○を試してみる </a><a class="tag" href="/categories/NET-Framework/NETで○○○を試してみる/難読化/" title="難読化">難読化 </a><a class="tag" href="/categories/NET-Framework/NETで○○○を試してみる/難読化/NETで難読化を試してみる/" title=".NETで難読化を試してみる">.NETで難読化を試してみる </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://takuya-takeuchi.github.io/2015/12/26/575/,A certain engineer &quot;COMPLEX&quot;,.NETで難読化を試してみる 第6回,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2015/12/28/617/" title=".NETで画像処理を試してみる OpenCVSharp編 第2回">前へ</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/12/26/590/" title=".NETで画像処理を試してみる OpenCVSharp編 第1回">次へ</a></li></ul></div></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/search.js"></script></body></html>