<!DOCTYPE html><html lang="ja-JP"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Core"><title>.NETでRPCを試してみる gRPC編 第1回 · A certain engineer "COMPLEX"</title><meta name="description" content="Introduction前回は導入手順の紹介しました。 C#をサポートしているので、試してみないわけにはいきません。 Pythonもサポートしており、簡単にテストできそうです。 内容としては、C#(クライアント)-Python(サーバー)とし、クライアントから送信した画像をサーバー側で反転して返すと"><meta name="keywords" content="极限博客,极限Blog,博客,极限"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.1.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">A certain engineer &quot;COMPLEX&quot;</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/mrcore"><i class="fa fa-github"></i></a></li><li><a href="mailto:x@jixian.io"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> Core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">ホーム</a></li><li><a href="/archives">アーカイブ</a></li><li><a href="/tags">タグ</a></li><li><a href="/about">自己紹介</a></li><li><a href="/guestbook">メッセージ</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>.NETでRPCを試してみる gRPC編 第1回</a></h3></div><div class="post-content"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><a target="_blank" rel="noopener" href="http://wp.me/p7138e-v2">前回</a>は導入手順の紹介しました。 C#をサポートしているので、試してみないわけにはいきません。 Pythonもサポートしており、簡単にテストできそうです。 内容としては、C#(クライアント)-Python(サーバー)とし、クライアントから送信した画像をサーバー側で反転して返すというプログラムになります。 今回のソースは下記になります。 </p>
<div class="blog-card"><div class="hbc-link-wrap"><a class="hbc-link" href="https://github.com/takuya-takeuchi/Demo/tree/master/gRPC1" target="_blank" rel="nofollow"><div class="hbc-card"><div class="hbc-info"><img class="hbc-favicon" src="http://www.google.com/s2/favicons?domain=github.com"></img><div class="hbc-site-name">GitHub</div></div><div class="hbc-contents"><div class="hbc-thumbnail"><img src="https://avatars0.githubusercontent.com/u/6241854?s=400&v=4"></img></div><div class="hbc-text"><div class="hbc-title">takuya-takeuchi/Demo</div><div class="hbc-url">https://github.com/takuya-takeuchi/Demo/tree/master/gRPC1</div><div class="hbc-description">Sample source code for Demonstration, Experiment and Test - takuya-takeuchi/Demo</div></div></div></div></a></div></div>

<h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>C#側は前回インストールしましたので省略します。</p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Pythonにもインストールしておきます。 Pythonインタープリターは、いつも通り<strong>Miniconda</strong>になります。 pipでインストールする場合は、pipのバージョンが8以降であることが条件です。 バージョンは下記の手順で確認。 [code lang=”batch”] C:\Program Files\Miniconda2&gt;python -m pip –version pip 9.0.1 from C:\Program Files\Miniconda2\lib\site-packages (python 2.7) [/code] <strong>gRPC</strong>をインストールします。 [code lang=”batch”] C:\Program Files\Miniconda2&gt;python -m pip install grpcio Collecting grpcio Downloading grpcio-1.2.0-cp27-cp27m-win_amd64.whl (1.1MB) 100% |################################| 1.1MB 846kB/s Requirement already satisfied: six&gt;=1.5.2 in c:\program files\miniconda2\lib\site-packages (from grpcio) Collecting protobuf&gt;=3.2.0 (from grpcio) Downloading protobuf-3.2.0-py2.py3-none-any.whl (360kB) 100% |################################| 368kB 1.8MB/s Requirement already satisfied: enum34&gt;=1.0.4 in c:\program files\miniconda2\lib\site-packages (from grpcio) Collecting futures&gt;=2.2.0 (from grpcio) Downloading futures-3.0.5-py2-none-any.whl Requirement already satisfied: setuptools in c:\program files\miniconda2\lib\site-packages\setuptools-20.3-py2.7.egg (from protobuf&gt;=3.2.0-&gt;grpcio) Installing collected packages: protobuf, futures, grpcio Found existing installation: protobuf 2.6.1 Uninstalling protobuf-2.6.1: Successfully uninstalled protobuf-2.6.1 Successfully installed futures-3.0.5 grpcio-1.2.0 protobuf-3.2.0 [/code] 続いて、<strong>gRPC tools</strong>をインストールします。 [code lang=”batch”] C:\Program Files\Miniconda2&gt;python -m pip install grpcio-tools Collecting grpcio-tools Downloading grpcio_tools-1.2.0-cp27-cp27m-win_amd64.whl (1.5MB) 100% |################################| 1.5MB 687kB/s Requirement already satisfied: grpcio&gt;=1.2.0 in c:\program files\miniconda2\lib\site-packages (from grpcio-tools) Requirement already satisfied: protobuf&gt;=3.2.0 in c:\program files\miniconda2\lib\site-packages (from grpcio-tools) Requirement already satisfied: six&gt;=1.5.2 in c:\program files\miniconda2\lib\site-packages (from grpcio&gt;=1.2.0-&gt;grpcio-tools) Requirement already satisfied: enum34&gt;=1.0.4 in c:\program files\miniconda2\lib\site-packages (from grpcio&gt;=1.2.0-&gt;grpcio-tools) Requirement already satisfied: futures&gt;=2.2.0 in c:\program files\miniconda2\lib\site-packages (from grpcio&gt;=1.2.0-&gt;grpcio-tools) Requirement already satisfied: setuptools in c:\program files\miniconda2\lib\site-packages\setuptools-20.3-py2.7.egg (from protobuf&gt;=3.2.0-&gt;grpcio-tools) Installing collected packages: grpcio-tools Successfully installed grpcio-tools-1.2.0[/code] gRPC toolsは <strong>proto</strong> というファイルから、サーバー、クライアント側のコードを生成するためのジェネレーターになります。</p>
<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><h2 id="gRPC-tools"><a href="#gRPC-tools" class="headerlink" title="gRPC tools"></a>gRPC tools</h2><p>protoファイルを用意して、サーバー、クライアントのコードを生成します。</p>
<h3 id="imageProc-proto"><a href="#imageProc-proto" class="headerlink" title="imageProc.proto"></a>imageProc.proto</h3><p>サンプルが <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">github</a> にありますが、面白くないので、手を加えます。 [code lang=”protobuf”] syntax = “proto3”;<br>package imageProc;<br>service ImageProc { rpc Enhancement (EnhancementRequest) returns (EnhancementReply) {} }<br>message EnhancementRequest { int32 width = 1; int32 height = 2; int32 channel = 3; bytes image = 4; }<br>message EnhancementReply { int32 result = 1; int32 width = 2; int32 height = 3; int32 channel = 4; bytes image = 5; } [/code] 続いて、imageProc.protoからコードを生成します。 gRPC toolsから生成しますが、PythonとC#側でそれぞれ生成する必要があります。 また、言語用にそれぞれgRPC toolsがあるので、それぞれ入手します。</p>
<h3 id="for-Python"><a href="#for-Python" class="headerlink" title="for Python"></a>for Python</h3><p>PythonでのgRPC toolsは下記のように使います。 [code lang=”batch”] python -m grpc_tools.protoc -I&lt;protoファイルの存在ディレクトリ&gt; –python_out=&lt;出力先のパス&gt; –grpc_python_out=&lt;出力先のパス&gt; &lt;protoファイルのパス&gt; [/code] 今回のソース構成では、gRPC1フォルダにimageProc.protoがありますので、そこをカレントディレクトリにして下記を実行します。 [code lang=”batch”] python -m grpc_tools.protoc -I. –python_out=python –grpc_python_out=python imageProc.proto [/code] これにより、<strong>Python\imageProc_pb2.py</strong>と<strong>Python\imageProc_pb2_grpc.py</strong> が生成されます。</p>
<h3 id="for-C"><a href="#for-C" class="headerlink" title="for C#"></a>for C#</h3><p>C#側は少し面倒です。 まず、nugetを入手します。 これはVisual Studioから実行できるものではなく、スタンドアロンのコマンドラインツールです。 <a target="_blank" rel="noopener" href="https://dist.nuget.org/index.html">Available NuGet Distribution Versions</a>から、<strong>nuget.exe - recommended latest (v3.5.0)**を選択します。 ダウンロードしたnuget.exeを適切な場所に展開し、ソースフォルダのpackagesフォルダをカレントディレクトにして、次のコマンドを入力します。 [code lang=”batch”] D:\Works\Demo\gRPC1\packages&gt;”C:\Program Files\NuGet\nuget.exe” install Grpc.Tools Feeds used: <a target="_blank" rel="noopener" href="https://api.nuget.org/v3/index.json">https://api.nuget.org/v3/index.json</a> C:\Program Files (x86)\Microsoft SDKs\NuGetPackages\<br>GET <a target="_blank" rel="noopener" href="https://api.nuget.org/v3/registration1-gz/grpc.tools/index.json">https://api.nuget.org/v3/registration1-gz/grpc.tools/index.json</a> OK <a target="_blank" rel="noopener" href="https://api.nuget.org/v3/registration1-gz/grpc.tools/index.json">https://api.nuget.org/v3/registration1-gz/grpc.tools/index.json</a> 672ms<br>Attempting to gather dependency information for package ‘Grpc.Tools.1.2.0’ with respect to project ‘D:\Works\Demo\gRPC1\packages’, targeting ‘Any,Version=v0.0’ Gathering dependency information took 15.35 ms Attempting to resolve dependencies for package ‘Grpc.Tools.1.2.0’ with DependencyBehavior ‘Lowest’ Resolving dependency information took 0 ms Resolving actions to install package ‘Grpc.Tools.1.2.0’ Resolved actions to install package ‘Grpc.Tools.1.2.0’ Retrieving package ‘Grpc.Tools 1.2.0’ from ‘nuget.org’. Adding package ‘Grpc.Tools.1.2.0’ to folder ‘D:\Works\Demo\gRPC1\packages’ Added package ‘Grpc.Tools.1.2.0’ to folder ‘D:\Works\Demo\gRPC1\packages’ Successfully installed ‘Grpc.Tools 1.2.0’ to D:\Works\Demo\gRPC1\packages Executing nuget actions took 176.33 ms [/code] カレントディレクトリに</strong>Grpc.Tools.1.2.0<strong>が作成されます。 続いて、コードを生成します。 構文はPythonと似ています。 [code lang=”batch”] protoc.exe -I&lt;protpファイルの存在ディレクトリ&gt; –csharp_out &lt;出力先のパス&gt; –grpc_out &lt;出力先のパス&gt; &lt;protoファイルのパス&gt; –plugin=protoc-gen-grpc=&lt;grpc_csharp_plugin.exeのパス&gt; [/code] grpc_csharp_plugin.exeは先ほどのnuget.exeでGrpc.Toolsをインストールした際に、同時にインストールされます。 ですので、下記のようにしてimageProc.protoからコードを生成します。 [code lang=”batch”] D:\Works\Demo\gRPC1&gt;mkdir gRPC\Contracts D:\Works\Demo\gRPC1&gt;packages\Grpc.Tools.1.2.0\tools\windows_x86\protoc.exe -I. –csharp_out gRPC\Contracts –grpc_out gRPC\Contracts imageProc.proto –plugin=protoc-gen-grpc=packages\Grpc.Tools.1.2.0\tools\windows_x86\grpc_csharp_plugin.exe [/code] これにより、</strong>gRPC\Contracts\ImageProc.cs<strong>と</strong>gRPC\Contracts\ImageProcGrpc.cs** が生成されます。</p>
<h2 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h2><p>コードの生成が完了したので、Python側でgRPCを利用するコードを記述していきます。</p>
<h3 id="imageProc-server-py"><a href="#imageProc-server-py" class="headerlink" title="imageProc_server.py"></a>imageProc_server.py</h3><p><strong>xxx_pb2_grpc.py</strong>というファイルにて、クライアント、サービスの基底クラスが定義されていますので、これらから派生したクラスを実装していきます。 Python側がサーバーになるので、<strong>ImageProcServicer</strong>から派生します。 [code lang=”python”] from concurrent import futures import time<br>import grpc<br>from PIL import Image import PIL.ImageOps import imageProc_pb2 import imageProc_pb2_grpc<br>_ONE_DAY_IN_SECONDS = 60 * 60 * 24<br>class ImageProc(imageProc_pb2_grpc.ImageProcServicer): def Enhancement(self, request, context): reply = imageProc_pb2.EnhancementReply() reply.width = request.width reply.height = request.height reply.channel = request.channel<br>imageSize = request.width, request.height # 1 (1-bit pixels, black and white, stored with one pixel per byte) # L (8-bit pixels, black and white) # P (8-bit pixels, mapped to any other mode using a colour palette) # RGB (3x8-bit pixels, true colour) # RGBA (4x8-bit pixels, true colour with transparency mask) # CMYK (4x8-bit pixels, colour separation) # YCbCr (3x8-bit pixels, colour video format) # I (32-bit signed integer pixels) # F (32-bit floating point pixels) channel = request.channel if channel == 4: print(‘channel is 4’) # PIL.ImageOps.invert does NOT support RGBA tmp = Image.frombytes(‘RGBA’, imageSize, request.image) r, g, b, a = tmp.split() rgb = Image.merge(“RGB”, (b, g, r)) inverted = PIL.ImageOps.invert(rgb) r, g, b = inverted.split() reply.image = Image.merge(“RGBA”, (r, g, b, a)).tobytes() elif channel == 3: print(‘channel is 3’) reply.image = PIL.ImageOps.invert(Image.frombytes(‘RGB’, imageSize, request.image)).tobytes() elif channel == 1: print(‘channel is 1’) reply.image = PIL.ImageOps.invert(Image.frombytes(‘1’, imageSize, request.image)).tobytes() else: print(‘channel is unknown’) reply.image = PIL.ImageOps.invert(Image.frombytes(‘L’, imageSize, request.image)).tobytes()<br>reply.result = 0 return reply<br>def serve(): server = grpc.server(futures.ThreadPoolExecutor(max_workers=10)) imageProc_pb2_grpc.add_ImageProcServicer_to_server(ImageProc(), server) server.add_insecure_port(‘[::]:50051’) server.start() try: while True: time.sleep(_ONE_DAY_IN_SECONDS) except KeyboardInterrupt: server.stop(0)<br>if __name__ == ‘__main__‘: serve() [/code] <strong>ImageProc</strong>は自動生成された<strong>ImageProcServicer</strong>から派生して適宜実装します。 今回は、入力されたバイナリデータを反転する処理を書いています。 main関数はserve関数を呼び出しています。 serve関数は、<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_server.py">https://github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_server.py</a>を参考に記述しますので簡単です。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><p>MVVMで実装します。 画像ファイルを読み込むボタン、読み込んだ画像を表示するパネル、サーバーと通信するための送信ボタン、サーバーからの結果を表示するためのパネルを備えています。 また、実装を開始する前に、nugetで<strong>Google.Protobuf</strong>をインストールします。</p>
<h3 id="MainViewModel-cs"><a href="#MainViewModel-cs" class="headerlink" title="MainViewModel.cs"></a>MainViewModel.cs</h3><p>まずは、interfaceです。 Xaml上のButtonに対応するCommandと、Imgaeに対応するImageSourceを備えているだけです。 [code lang=”csharp”] using System.Windows.Media; using GalaSoft.MvvmLight.Command;<br>namespace Grpc1.ViewModels.Interfaces {<br>public interface IMainViewModel {<br>#region Properties<br>RelayCommand OpenFileCommand { get; }<br>ImageSource ResultImage { get; }<br>RelayCommand ServerRequestCommand { get; }<br>ImageSource SourceImage { get; }<br>#endregion<br>}<br>} [/code]</p>
<h3 id="IMainViewModel-cs"><a href="#IMainViewModel-cs" class="headerlink" title="IMainViewModel.cs"></a>IMainViewModel.cs</h3><p><strong>IMainViewModel</strong>を継承しています。 [code lang=”csharp”] using System; using System.Windows; using System.Windows.Media; using System.Windows.Media.Imaging; using GalaSoft.MvvmLight; using GalaSoft.MvvmLight.Command; using Google.Protobuf; using Grpc1.ViewModels.Interfaces; using ImageProc; using Microsoft.WindowsAPICodePack.Dialogs;<br>namespace Grpc1.ViewModels {<br>internal sealed class MainViewModel : ViewModelBase, IMainViewModel {<br>#region Properties<br>private RelayCommand _OpenFileCommand;<br>public RelayCommand OpenFileCommand { get { return this._OpenFileCommand ?? (this._OpenFileCommand = new RelayCommand(() =&gt; { using (var dlg = new CommonOpenFileDialog()) { dlg.IsFolderPicker = false; dlg.AddToMostRecentlyUsedList = false; dlg.AllowNonFileSystemItems = false; dlg.EnsureFileExists = true; dlg.EnsurePathExists = true; dlg.EnsureReadOnly = false; dlg.EnsureValidNames = true; dlg.Multiselect = false; dlg.ShowPlacesList = true;<br>var dialogResult = dlg.ShowDialog(); if (dialogResult != CommonFileDialogResult.Ok) return;<br>var bitmap = new BitmapImage(); try { bitmap.BeginInit(); bitmap.UriSource = new Uri(dlg.FileName); bitmap.EndInit(); this.SourceImage = bitmap; } catch (Exception ex) { MessageBox.Show(ex.Message); } }<br>this._ServerRequestCommand?.RaiseCanExecuteChanged(); }, () =&gt; true)); } }<br>private ImageSource _ResultImage;<br>public ImageSource ResultImage { get { return this._ResultImage; } private set { this._ResultImage = value; this.RaisePropertyChanged(); } }<br>private RelayCommand _ServerRequestCommand;<br>public RelayCommand ServerRequestCommand { get { return this._ServerRequestCommand ?? (this._ServerRequestCommand = new RelayCommand(async () =&gt; { var bitmap = this._SourceImage as BitmapImage; if (bitmap == null) return;<br>var width = bitmap.PixelWidth; var height = bitmap.PixelHeight; var stride = (width * bitmap.Format.BitsPerPixel + 7) / 8; var bitsPerPixel = bitmap.Format.BitsPerPixel; var bytesPerPixel = bitsPerPixel / 8; var originalPixels = new byte[width * height * bytesPerPixel]; bitmap.CopyPixels(originalPixels, stride, 0);<br>try { var channel = new Grpc.Core.Channel(“127.0.0.1:50051”, Grpc.Core.ChannelCredentials.Insecure); var client = new ImageProc.ImageProc.ImageProcClient(channel); var reply = await client.EnhancementAsync(new EnhancementRequest { Height = height, Width = width, Channel = bytesPerPixel, Image = ByteString.CopyFrom(originalPixels) }); channel.ShutdownAsync().Wait();<br>var resultPixels = reply.Image.ToByteArray(); if (resultPixels != null) { var bmpSource = BitmapSource.Create( width, height, bitmap.DpiX, bitmap.DpiY, bitmap.Format, null, resultPixels, stride); if (bmpSource.CanFreeze) bmpSource.Freeze();<br>this.ResultImage = bmpSource; } } catch {<br>} }, () =&gt; this._SourceImage != null)); } }<br>private ImageSource _SourceImage;<br>public ImageSource SourceImage { get { return this._SourceImage; } private set { this._SourceImage = value; this.RaisePropertyChanged(); } }<br>#endregion<br>}<br>} [/code] <strong>OpenFileCommand</strong>は、画像ファイルを<strong>System.Windows.Media.Imaging.BitmapImage</strong>に変換して、<strong>SourceImage</strong>に設定するだけです。 注目は、<strong>ServerRequestCommand</strong>の下記の部分です。 [code lang=”csharp”] var channel = new Grpc.Core.Channel(“127.0.0.1:50051”, Grpc.Core.ChannelCredentials.Insecure); var client = new ImageProc.ImageProc.ImageProcClient(channel); var reply = await client.EnhancementAsync(new EnhancementRequest { Height = height, Width = width, Channel = bytesPerPixel, Image = ByteString.CopyFrom(originalPixels) }); channel.ShutdownAsync().Wait(); [/code] ローカル(127.0.0.1)のポート50051に対して、gRPCで通信を確立し、APIを呼び出しています。 <strong>ImageProc.ImageProc.ImageProcClient</strong>は、gRPC toolsで自動生成しているものです。 通信に関係するコードはすべて自動で生成されるので、クライアント側は、ちょっとした呼び出しのコードを記述するだけで、簡単にサーバー側のAPIを呼び出せるわけです。</p>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>サーバー側とクライアント側をテストしてみます。 サーバー側(<strong>imageProc_server.py</strong>)を起動し、任意の画像ファイルを読み込み、サーバー側APIを呼び出すと、反転した画像が返ってきます。<br><a href="../../../../public/2017/03/test-2.gif"><img src="../../../../public/2017/03/test-2-1024x417.gif"></a></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>通信周りはすべて自動生成に任せ、ビジネスロジックの実装に注力できるのは、本当に楽です。 今時、ソケットだのコールバックだの考えるのは本当に面倒です。</p>
<h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><p><a target="_blank" rel="noopener" href="https://github.com/takuya-takeuchi/Demo/tree/master/gRPC1">https://github.com/takuya-takeuchi/Demo/tree/master/gRPC1</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-03-27</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Microsoft/" title="Microsoft">Microsoft </a><a class="tag" href="/categories/Microsoft/NET-Framework/" title=".NET Framework">.NET Framework </a><a class="tag" href="/categories/net-framework/" title="net-framework">net-framework </a><a class="tag" href="/categories/net-framework/NETで○○○を試してみる/" title=".NETで○○○を試してみる">.NETで○○○を試してみる </a><a class="tag" href="/categories/netで○○○を試してみる/" title="netで○○○を試してみる">netで○○○を試してみる </a><a class="tag" href="/categories/remote-procedure-call/" title="remote-procedure-call">remote-procedure-call </a><a class="tag" href="/categories/remote-procedure-call/gRPC/" title="gRPC">gRPC </a><a class="tag" href="/categories/netで○○○を試してみる/NETでRPCを試してみる/" title=".NETでRPCを試してみる">.NETでRPCを試してみる </a><a class="tag" href="/categories/Remote-Procedure-Call/" title="Remote Procedure Call">Remote Procedure Call </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://takuya-takeuchi.github.io/2017/03/27/1929/,A certain engineer &quot;COMPLEX&quot;,.NETでRPCを試してみる gRPC編 第1回,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/03/27/1947/" title="開発メモ その35 protoファイルからドキュメントを生成する">前へ</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/03/26/1924/" title=".NETでRPCを試してみる gRPC編 第0回">次へ</a></li></ul></div></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script></body></html>