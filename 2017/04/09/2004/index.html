<!DOCTYPE html><html lang="ja-JP"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Core"><title>.NETでRPCを試してみる Apache Thrift編 第1回 · A certain engineer "COMPLEX"</title><meta name="description" content="Introduction前回は、Apache Thriftのビルドを実施しました。 今回は、C++のサーバーとC#のクライアントを作成します。 今回のソースは下記になります。 
GitHubtakuya-takeuchi/Demohttps://github.com/takuya-takeuchi/"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/blogcard.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.1.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">A certain engineer &quot;COMPLEX&quot;</a></h3><div class="description"><p>とある技術者の劣等感</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/takuya-takeuchi"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="noopener" href="https://twitter.com/takuya_takeuchi"><i class="fa fa-twitter-square"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.facebook.com/takuya.takeuchi.sns"><i class="fa fa-facebook-square"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2020 </span><i class="fa fa-star"></i><span> Core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="search"><div class="text"><input placeholder="検索ワードを入力してください" id="search-text" onkeypress="javascript:search(event)"></div><div class="btn"><a><i class="fa fa-search"></i></a></div></div><div class="nav"><li><a href="/">ホーム</a></li><li><a href="/archives">アーカイブ</a></li><li><a href="/tags">タグ</a></li><li><a href="/about">自己紹介</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>.NETでRPCを試してみる Apache Thrift編 第1回</a></h3></div><div class="post-content"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><a target="_blank" rel="noopener" href="https://taktak.jp/2017/04/09/1991">前回</a>は、<strong>Apache Thrift</strong>のビルドを実施しました。 今回は、C++のサーバーとC#のクライアントを作成します。 今回のソースは下記になります。 </p>
<div class="blog-card"><div class="hbc-link-wrap"><a class="hbc-link" href="https://github.com/takuya-takeuchi/Demo/tree/master/RPC-ApacheTrift1" target="_blank" rel="nofollow"><div class="hbc-card"><div class="hbc-info"><img class="hbc-favicon" src="http://www.google.com/s2/favicons?domain=github.com"></img><div class="hbc-site-name">GitHub</div></div><div class="hbc-contents"><div class="hbc-thumbnail"><img src="https://avatars0.githubusercontent.com/u/6241854?s=400&v=4"></img></div><div class="hbc-text"><div class="hbc-title">takuya-takeuchi/Demo</div><div class="hbc-url">https://github.com/takuya-takeuchi/Demo/tree/master/RPC-ApacheTrift1</div><div class="hbc-description">Sample source code for Demonstration, Experiment and Test - takuya-takeuchi/Demo</div></div></div></div></a></div></div>

<h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>順番に作成していきます。</p>
<h2 id="Win32コンソールアプリ"><a href="#Win32コンソールアプリ" class="headerlink" title="Win32コンソールアプリ"></a>Win32コンソールアプリ</h2><p>Visual Stuidoで、Win32コンソールアプリを作成します。</p>
<h3 id="追加のインクルード-ディレクトリ"><a href="#追加のインクルード-ディレクトリ" class="headerlink" title="追加のインクルード ディレクトリ"></a>追加のインクルード ディレクトリ</h3><p>作成したプロジェクトのプロパティから<code>C/C++ -&gt; 全般</code>を開き、<strong>追加のインクルード ディレクトリ</strong>に下記を追加します。</p>
<ul>
<li>{boost_install_dir}</li>
<li>{thrift_install_dir}\lib\cpp\src\thrift\windows</li>
<li>{thrift_install_dir}\lib\cpp\src\thrift</li>
<li>{thrift_install_dir}\lib\cpp\src</li>
</ul>
<h3 id="追加の依存ファイル"><a href="#追加の依存ファイル" class="headerlink" title="追加の依存ファイル"></a>追加の依存ファイル</h3><p><code>ライブラリアン -&gt; 入力</code>を開き、<strong>追加の依存ファイル</strong>に下記を追加します。</p>
<ul>
<li>libboost_thread-vc140-mt-gd-1_59.lib</li>
<li>libboost_chrono-vc140-mt-gd-1_59.lib</li>
<li>libthrift.lib</li>
<li>libthriftnb.lib</li>
<li>libeay32.lib</li>
<li>ssleay32.lib</li>
</ul>
<h3 id="追加のライブラリ-ディレクトリ"><a href="#追加のライブラリ-ディレクトリ" class="headerlink" title="追加のライブラリ ディレクトリ"></a>追加のライブラリ ディレクトリ</h3><p><code>ライブラリアン -&gt; 全般</code>を開き、<strong>追加のライブラリ ディレクトリ</strong>に下記を追加します。</p>
<ul>
<li>{boost_install_dir}\lib64-msvc-14.0</li>
<li>{thrift_install_dir}\lib\cpp\Debug</li>
<li>{openssll_install_dir}\lib</li>
</ul>
<p>lib64-msvc-14.0は、インストールしたboostのVCのバージョンに依存します。<strong>lib64-msvc-12.0</strong>かもしれません。 最後の、<strong>Debug</strong>の部分は、<strong>Release, Release-mt, Debug, Debug-mt</strong>から好きなのを選んでください。つまり、libthriftビルド時の出力先です。</p>
<h2 id="thriftファイル"><a href="#thriftファイル" class="headerlink" title=".thriftファイル"></a>.thriftファイル</h2><p>クライアントとサーバーを生成するための定義ファイルです。 今回は下記のようなファイル<strong>ImageProcService.thrift</strong>です。 [code lang=”thrift”] service imageProcService { binary Revert(1:binary image,2:i32 width,3:i32 height), } [/code] <strong>Revert</strong>は渡されたバイナリ(RAW画像データ)の画素を反転させます。</p>
<h2 id="コード生成"><a href="#コード生成" class="headerlink" title="コード生成"></a>コード生成</h2><p>前回ダウンロードしたThriftのコンパイラーを使ってコードを生成します。 [code lang=”batch”] thrift-0.10.0.exe-r –gen cpp ImageProcService.thrift [/code] 上記のコマンドで、<strong>gen-cpp</strong>というフォルダが生成され、その中に、</p>
<ul>
<li>imageProcService.cpp</li>
<li>imageProcService.h</li>
<li>imageProcService_server.skeleton.cpp</li>
<li>Server_constants.cpp</li>
<li>Server_constants.h</li>
<li>Server_types.cpp</li>
<li>Server_types.h</li>
</ul>
<p>が作成されます。</p>
<h2 id="for-C"><a href="#for-C" class="headerlink" title="for C++"></a>for C++</h2><p>サーバー側です。 前項の、<strong>imageProcService_server.skeleton.cpp</strong>がサーバー側の実装のスケルトンコードなので、そのまま流用します。 下記がソースです。 [code lang=”cpp”] // Server.cpp : コンソール アプリケーションのエントリ ポイントを定義します。 //<br>#include “stdafx.h” #include “gen-cpp/imageProcService.h” #include &lt;thrift/protocol/TBinaryProtocol.h&gt; #include &lt;thrift/server/TSimpleServer.h&gt; #include &lt;thrift/transport/TServerSocket.h&gt; #include &lt;thrift/transport/TBufferTransports.h&gt;<br>using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server;<br>using boost::shared_ptr;<br>class imageProcServiceHandler : virtual public imageProcServiceIf { public: imageProcServiceHandler() { // Your initialization goes here }<br>void Revert(std::string&amp; _return, const std::string&amp; image, const int32_t width, const int32_t height) { unsigned char* tmp = static_cast&lt;unsigned char*&gt;(malloc(sizeof(unsigned char) * image.length())); copy(image.begin(), image.end(), tmp);<br>printf(“image length: %llu\n”, image.length());<br>for (int index = 0; index &lt; image.length(); index++) tmp[index] = 255 - tmp[index];<br>_return.append(tmp, tmp + image.length()); printf(“_return length: %llu\n”, image.length()); free(tmp);<br>printf(“Revert\n”); }<br>};<br>int main() { int port = 9090; shared_ptr<imageProcServiceHandler> handler(new imageProcServiceHandler()); shared_ptr<TProcessor> processor(new imageProcServiceProcessor(handler)); shared_ptr<TServerTransport> serverTransport(new TServerSocket(port)); shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory()); shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());<br>TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); server.serve(); return 0; }[/code] 注意するのは、*<em>.thrift<strong>で指定したimageの型がbinaryなのに、</strong>std::string<strong>になっていることでしょう。 これはバグではなく仕様です。</strong>unsigned char**</em>になることを期待していましたが仕方ありません。 なので、うまく型を変換して内部のデータにアクセスします。 戻りもstd::stringなので、操作したデータを格納するようにします。 しかし、ビルドが通りません。 どうも調べてみると<strong>libthrift</strong>のソースでいくつか必要なファイルがプロジェクトから除外されていることが原因の模様。 そのため、libthriftのプロジェクトに下記を追加します。</p>
<ul>
<li>src\thrift\server\TConnectedClient.cpp”</li>
<li>src\thrift\server\TConnectedClient.h</li>
<li>src\thrift\server\TNonblockingServer.cpp</li>
<li>src\thrift\server\TNonblockingServer.h</li>
<li>src\thrift\server\TServer.cpp</li>
<li>src\thrift\server\TServerFramework.cpp</li>
<li>src\thrift\server\TServerFramework.h</li>
</ul>
<p>次に、libthriftのプロパティを開きます。 C/C++ -&gt; 全般を開き、追加のインクルード ディレクトリに下記を追加します。</p>
<ul>
<li>{libevent_install_dir}</li>
<li>{libevent_install_dir}\include</li>
<li>{libevent_install_dir}\WIN32-Code\nmake</li>
</ul>
<p>これで、libthriftを再度ビルドし、利用する側もリビルドします。 今度は成功するはずです。</p>
<h2 id="for-C-1"><a href="#for-C-1" class="headerlink" title="for C"></a>for C</h2><p>クライアント側のソースです。 C++側と異なり、Thriftのビルドは不要でNugetで完結します。 パッケージマネージャー コンソールから下記のコマンドでインストールします。 [code lang=”batch”] Install-Package ApacheThrift -Pre [/code] 2017/04/09現在、安定版は、0.9.3が最新で、C++の最新版である0.10.0とは異なるので不安ですが、これしかないので、これを使います。 クライアントである、C#側は、<a target="_blank" rel="noopener" href="https://taktak.jp/2017/03/27/1929">.NETでRPCを試してみる gRPC編 第1回</a>と同じ感じです。 クライアントのソースは、Thriftのコンパイラーを使ってコードを生成します。 [code lang=”batch”] thrift-0.10.0.exe-r –gen csharp ImageProcService.thrift [/code] で生成できます。<strong>gen-csharp</strong>というフォルダが生成され、その中に、</p>
<ul>
<li>imageProcService.cs</li>
</ul>
<p>だけ生成されます。 上記のファイルをC#プロジェクトの適切なフォルダに移動します。 サーバーへアクセスするソースだけ記載します。 [code lang=”csharp”] using System; using System.Windows; using System.Windows.Media; using System.Windows.Media.Imaging; using GalaSoft.MvvmLight; using GalaSoft.MvvmLight.Command; using ImageProcClient.Contracts; using ImageProcClient.ViewModels.Interfaces; using Microsoft.WindowsAPICodePack.Dialogs; using Thrift.Protocol; using Thrift.Transport;<br>namespace ImageProcClient.ViewModels {<br>internal sealed class MainViewModel : ViewModelBase, IMainViewModel {<br>#region Properties<br>private RelayCommand _OpenFileCommand;<br>public RelayCommand OpenFileCommand { get { return this._OpenFileCommand ?? (this._OpenFileCommand = new RelayCommand(() =&gt; { using (var dlg = new CommonOpenFileDialog()) { dlg.IsFolderPicker = false; dlg.AddToMostRecentlyUsedList = false; dlg.AllowNonFileSystemItems = false; dlg.EnsureFileExists = true; dlg.EnsurePathExists = true; dlg.EnsureReadOnly = false; dlg.EnsureValidNames = true; dlg.Multiselect = false; dlg.ShowPlacesList = true;<br>var dialogResult = dlg.ShowDialog(); if (dialogResult != CommonFileDialogResult.Ok) return;<br>var bitmap = new BitmapImage(); try { bitmap.BeginInit(); bitmap.UriSource = new Uri(dlg.FileName); bitmap.EndInit(); this.SourceImage = bitmap; } catch (Exception ex) { MessageBox.Show(ex.Message); } }<br>this._ServerRequestCommand?.RaiseCanExecuteChanged(); }, () =&gt; true)); } }<br>private ImageSource _ResultImage;<br>public ImageSource ResultImage { get { return this._ResultImage; } private set { this._ResultImage = value; this.RaisePropertyChanged(); } }<br>private RelayCommand _ServerRequestCommand;<br>public RelayCommand ServerRequestCommand { get { return this._ServerRequestCommand ?? (this._ServerRequestCommand = new RelayCommand(() =&gt; { var bitmap = this._SourceImage as BitmapImage; if (bitmap == null) return;<br>var width = bitmap.PixelWidth; var height = bitmap.PixelHeight; var stride = (width * bitmap.Format.BitsPerPixel + 7) / 8; var bitsPerPixel = bitmap.Format.BitsPerPixel; var bytesPerPixel = bitsPerPixel / 8; var originalPixels = new byte[width * height * bytesPerPixel]; bitmap.CopyPixels(originalPixels, stride, 0);<br>try { TTransport transport = new TSocket(“localhost”, 9090); TProtocol protocol = new TBinaryProtocol(transport); imageProcService.Client client = new imageProcService.Client(protocol);<br>transport.Open(); try { client.send_Revert(originalPixels, width, height); var resultPixels = client.recv_Revert(); if (resultPixels != null) { var bmpSource = BitmapSource.Create( width, height, bitmap.DpiX, bitmap.DpiY, bitmap.Format, null, resultPixels, stride); if (bmpSource.CanFreeze) bmpSource.Freeze();<br>this.ResultImage = bmpSource; } } finally { transport.Close(); } } catch (Exception x) { Console.WriteLine(x.StackTrace); }<br>}, () =&gt; this._SourceImage != null)); } }<br>private ImageSource _SourceImage;<br>public ImageSource SourceImage { get { return this._SourceImage; } private set { this._SourceImage = value; this.RaisePropertyChanged(); } }<br>#endregion<br>}<br>} [/code] <strong>gRPC</strong>とことなり、メソッドの呼び出し(<strong>send_XXXX</strong>)で即座に結果を返すわけでなく、<strong>recv_XXXX</strong>を追加で呼ぶ必要があります。 こうなると、余計な通信が発生する気がしますが…そういう仕様なので仕方ないのでしょう。</p>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>実行結果です。 入力画像が反転しているのがわかります。<br><a href="../../../../public/2017/04/test.gif"><img src="../../../../public/2017/04/test-1024x419.gif"></a><br> 別マシンでサーバーを起動して、IPを変更してもきちんと動きます。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>C++側が面倒でしたが、それ以外はgRPCと大差ありません。 一度ライブラリを作ってしまえば後は流用できますので、導入コストが少し高いだけです。 その後は、マシン間通信がこれでもか、というくらい楽になります。 C++でサーバー側を実装するなら、gRPCよりもThriftのがおすすめな感じはします(gRPCのC++は試していませんが…)</p>
<h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><p><a target="_blank" rel="noopener" href="https://github.com/takuya-takeuchi/Demo/tree/master/RPC-ApacheTrift1">https://github.com/takuya-takeuchi/Demo/tree/master/RPC-ApacheTrift1</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-04-09</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Microsoft/" title="Microsoft">Microsoft </a><a class="tag" href="/categories/Microsoft/NET-Framework/" title=".NET Framework">.NET Framework </a><a class="tag" href="/categories/net-framework/" title="net-framework">net-framework </a><a class="tag" href="/categories/net-framework/NETで○○○を試してみる/" title=".NETで○○○を試してみる">.NETで○○○を試してみる </a><a class="tag" href="/categories/netで○○○を試してみる/" title="netで○○○を試してみる">netで○○○を試してみる </a><a class="tag" href="/categories/remote-procedure-call/" title="remote-procedure-call">remote-procedure-call </a><a class="tag" href="/categories/netで○○○を試してみる/NETでRPCを試してみる/" title=".NETでRPCを試してみる">.NETでRPCを試してみる </a><a class="tag" href="/categories/remote-procedure-call/Apache-Thrift/" title="Apache Thrift">Apache Thrift </a><a class="tag" href="/categories/Remote-Procedure-Call/" title="Remote Procedure Call">Remote Procedure Call </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://takuya-takeuchi.github.io/2017/04/09/2004/,A certain engineer &quot;COMPLEX&quot;,.NETでRPCを試してみる Apache Thrift編 第1回,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/04/11/2011/" title="開発メモ その42 環境変数PATHの最大長を2047から4095に緩和する">前へ</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/04/09/1991/" title=".NETでRPCを試してみる Apache Thrift編 第0回">次へ</a></li></ul></div></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/search.js"></script></body></html>